/**
 * @file first.c
 * @author anger
 * @brief 第一个 C 语言文件
 * @date 2022-08-17
 * 
 * include <stdio.h> 告诉编译器需要使用哪些外部库
 * stdio.h 库中包含能在终端读写数据的代码
 * 
 * 使用 gcc file.c -o filename && ./filename
 * 进行编译并执行编译后的文件
 */
# include <stdio.h>
# include <stdlib.h>

/**
 * @brief main 函数
 * 所有 C 语言的代码都在函数中运行
 * main() 函数是程序中所有代码的起点
 * @return int 整型
 * 计算机在运行程序时
 * 需要通过一些方法来判断程序是否运行成功
 * 通过检查 main 函数的返回值来实现这一点
 * 如果返回 0 则表示运行成功
 * 返回其他值则表示运行发生了问题
 */
int main()
{
    /**
     * @brief 创建一个字符数组用于接收用户输入的信息
     * C 语言比其他语言的抽象程度更低
     * 不提供字符串
     * 使用类似的东西来替代字符串
     * C 语言会将字符串当做字符数组来读取
     * 每一个字符都是数组中的一个元素
     * 可以通过索引来引用字符串中的某个字符
     * C 语言想要读取字符串时
     * 不确切知道字符串有多长
     * 需要知道什么时候读取到了字符串的尾部
     * 为此 C 语言加入了哨兵字符 
     * 哨兵字符是在字符串末尾的附加字符，值为 \0
     * 计算机读取到了 \0 则认为是已经读取完了这一串字符串
     * \0 是 ASCII 字符，值为 0，通常称之为 null （空字符）
     * "aa" -> aa\0
     * card_name[3] 实际只会记录 2 个字符
     * 但是由于要以哨兵字符结尾
     * 所以需要把数组的大小定义为 3
     * 
     * 字符索引以 0 开始
     * 因为这个索引是一个偏移量
     * 表示要引用的这个字符到字符串第一个字符之间有多少字符
     * 计算机在寄存器中以连续的字节保存字符
     * 使用索引计算出字符在寄存器中的位置
     * 如果 c[0] 在寄存器中的 1_000_000 单元
     * 那么很快就可以计算出 c[10] 在寄存器中的 1_000_010 单元
     * 使用这种计数方法能够很快计算出某个字符在寄存器中的位置
     * 
     * 'c' 'str'
     * 单引号一般用于表示单个字符
     * 双引号用于表示字符串
     * 使用双引号表示的字符串叫做字符串字面量
     * 比起数组更加方便
     * 比起数组
     * 字符串字面量是一个常量，一旦创建则无法修改
     */
    char card_name[3];
    // 在命令行或者终端提示的字符串
    puts("输入牌面：");
    // 取输入的前两位作为 card_name 的值
    scanf("%2s", card_name);
    int val = 0;
    // 如果第一位为 Q 则给 val 赋值为 10
    if (card_name[0] == 'Q') val = 10;
    else if (card_name[0] == 'J') val = 10;
    else if (card_name[0] == 'K') val = 10;
    else if (card_name[0] == 'A') val = 11;
    else val = atoi(card_name);
    // 格式化字符串 %i 表示一个 int 类型占位符，需要一个 int 类型数值作为参数
    printf("这张牌的点数是：%i\n", val);
    return 0;
}